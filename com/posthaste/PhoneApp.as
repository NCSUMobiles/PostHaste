package {		/*		BUG LIST Version 23				Known Issues:		FIXED 1. S2PictureBg setMediaPromise... (MediaPromise is currently null)		FIXED 2. Pictures won't copy into directory until S2PictureBg stores file URL from MediaPromise		FIXED 3. XML <Text> currently stores text from only one rsvp text frame, may not match up correctly		4. Film Strip/Background images not reloading after leaving screen		5. RSVP text display formatting issues (change?, centered, multiline, etc)		SEE V22 6. Save image from bitmap not mediaPromise				Feature Requests: 		1. Preview Playback speed/location scroller		2. Swap images (select existing S2PictureBG frame and call cameraroll)		3. Delete images (use swap image and imageSelectionCanceled)		4. Send/Share/Upload Files		5. Trash current presentation		6. Load presentation from XML		7. Adjust Frame size to maintain aspect ratio of image	*/		import flash.display.StageScaleMode;	import flash.ui.Multitouch;	import flash.ui.MultitouchInputMode;	import flash.events.MouseEvent;	import fl.controls.Button;	import flash.display.MovieClip;	import fl.transitions.Tween;	import fl.transitions.easing.*;	import flash.text.TextFormat;	import flash.text.TextFieldAutoSize;	import fl.transitions.TweenEvent;	import flash.text.TextField;	import flash.events.Event;	import flash.utils.getTimer;	import flash.events.TransformGestureEvent;	import flash.events.MediaEvent;	import flash.media.CameraRoll;	import fl.display.ProLoader;	import flash.display.Sprite;	import flash.events.IOErrorEvent;	import flash.display.Bitmap;	import flash.geom.Rectangle;	import flash.utils.Dictionary;	import flash.filesystem.*;	import flash.xml.*;	import flash.display.NativeMenu;	import com.posthaste.S2PictureBg;	import flash.geom.*;	import flash.display.*;	import com.senocular.images.BMPEncoder;	import com.adobe.images.PNGEncoder;	import flash.net.FileReference;	import flash.utils.ByteArray;		public class PhoneApp extends MovieClip {		Multitouch.inputMode = MultitouchInputMode.GESTURE;				var NAV_TWEEN_TIME:Number = 0.5;		var RSVP_LENGTH:uint = 20;		var MIN_RSVP_TIME:uint = 100;		var MAX_RSVP_TIME:uint = 5000;		var RSVP_DISP_TIME_NORMAL:uint = 1000;		var RSVP_DISP_TIME_AFTER_SENTENCE:uint = 2000;		var SPEED_DELTA:uint = 250;		//var PUNCTUATION:Array = new Array(".", "!", "?", "\n");		var PUNCTUATION:Array = new Array(".", "!", "?");		var afterSentence:Boolean = false;		var presentationDict:Dictionary = new Dictionary();		var rsvpTextField:TextField = new TextField();		var s2RsvpTextField:TextField = new TextField();		var rsvpPiecesArray:Array = new Array();		var curRsvpIndex:int = -1;		var lastRsvpUpdateTime:int;		var currentScreen:uint = 1;		var previewPaused:Boolean = false;		var rsvpBgPos:Number;		var postHasteTitlePos:Number;		var messageTextPos:Number;		var galleryItemsPos:Number;		var galleryItemsArray:Array = new Array();		var curSelectedGalleryIndex:uint = 0;		var GALLERY_ITEMS_SPACING:Number = 30;				//FOR TESTING ONLY, DELETE LATER:		//var testCameraRollTextField:TextField = new TextField();				public function PhoneApp() {			stage.scaleMode = StageScaleMode.EXACT_FIT;						var format:TextFormat = new TextFormat("Helvetica", 35);			messageText.setStyle("textFormat", format);									rsvpTextField.visible = false;			s2RsvpTextField.visible = false;			var rsvpFormat:TextFormat = new TextFormat("Helvetica", 35);			rsvpTextField.defaultTextFormat = rsvpFormat;			rsvpTextField.x = rsvpPreviewBg.x;			rsvpTextField.width = rsvpPreviewBg.width;			//rsvpTextField.autoSize = TextFieldAutoSize.CENTER;			rsvpTextField.selectable = false;			s2RsvpTextField.defaultTextFormat = rsvpFormat;			s2RsvpTextField.x = rsvpPreviewBg.x;			s2RsvpTextField.width = s2RsvpBg.width;			s2RsvpTextField.selectable = false;			//s2RsvpTextField.autoSize = TextFieldAutoSize.CENTER;			setRsvpLength();			addChild(rsvpTextField);			addChild(s2RsvpTextField);									rsvpBgPos = rsvpPreviewBg.x;			postHasteTitlePos = postHasteTitle.x;			messageTextPos = messageText.x;			galleryItemsPos = galleryItems.x;			// FIXME: next three lines are a Hack to make the second screen not			// obscure the preview screen if the user goes directly there.			s2Background.x = -s2Background.width - 5;			s2ProgBar.x = -s2ProgBar.width - 5;			s2RsvpBg.x = -s2RsvpBg.width - 5;			galleryItems.x = -galleryItems.width - 5;									// Setup some event listeners			previewBtn.addEventListener(MouseEvent.CLICK, previewBtnClicked);			trashBtn.addEventListener(MouseEvent.CLICK, trashBtnClicked);			s1Background.addEventListener(MouseEvent.CLICK, s1BgClicked);			s1NextBtn.addEventListener(MouseEvent.CLICK, screen1NextBtnClicked);			backBtn.addEventListener(MouseEvent.CLICK, backBtnClicked);			rsvpPreviewBg.addEventListener(MouseEvent.MOUSE_DOWN, pausePreview);			rsvpPreviewBg.addEventListener(MouseEvent.MOUSE_UP, unpausePreview);			rsvpTextField.addEventListener(MouseEvent.MOUSE_DOWN, pausePreview);			rsvpTextField.addEventListener(MouseEvent.MOUSE_UP, unpausePreview);			s2RsvpBg.addEventListener(TransformGestureEvent.GESTURE_SWIPE, s2RsvpSwipe);			s3Background.addEventListener(TransformGestureEvent.GESTURE_SWIPE, s3RsvpSwipe);			s2RsvpTextField.addEventListener(TransformGestureEvent.GESTURE_SWIPE, s2RsvpSwipe);			saveBtn.addEventListener(MouseEvent.CLICK, saveFile);						// Presentation creation, and galleryItems...			galleryItems.imgBg1.addEventListener(MouseEvent.CLICK, launchCameraRoll);			s2Background.addEventListener(TransformGestureEvent.GESTURE_SWIPE, s2BackgroundSwipe);			galleryItemsArray[0] = galleryItems.imgBg1;			curSelectedGalleryIndex = 0;						//testCameraRollTextField.x = 10;			//testCameraRollTextField.y = 100;			//testCameraRollTextField.width = 300;			//testCameraRollTextField.multiline = true;			//testCameraRollTextField.wordWrap = true;			//addChild(testCameraRollTextField);		}						/*			ON SCREEN MOUSE EVENTS		*/		private function s1BgClicked(e:MouseEvent):void {			// NOTE: Oddly enough, Flash on the iPhone does not give you			// a Done button on the keyboard for a TextArea, so there's no way			// to dismiss it.  There's probably a way to change the keyboard			// type that it pops up, but for now, just make a click on the			// scene1 background remove focus from the TextArea.  Also			// this is the dumbest way to remove focus I've ever seen, but			// it works.			messageText.focusManager.deactivate();		}				private function trashBtnClicked(e:MouseEvent):void {			// TODO:			// 1.) clear state variables			// 2.) clear a few bitmaps			// 3.) clear the messageText.text		}				private function screen1NextBtnClicked(e:MouseEvent):void {			moveS1OffLeft();			moveS2OnLeft();			currentScreen = 2;		}				public function backBtnClicked(e:MouseEvent):void {			moveS1OnRight();			switch(currentScreen) {				case 2:					moveS2OffRight();					break;				case 3:					moveS3OffRight();					break;				default:					break;			}			currentScreen = 1;		}				private function previewBtnClicked(e:MouseEvent):void {			if (currentScreen == 3) {				if (curRsvpIndex != -1)					return;									startPreview(null);				return;			}						moveS3OnLeft();			switch(currentScreen) {				case 1:					moveS1OffLeft();					break;				case 2:					moveS2OffLeft();					break;				default:					break;			}			currentScreen = 3;		}						/*			SCREEN TRANSITIONS		*/		private function moveS1OffLeft():void {			var tween1:Tween = new Tween(messageText, "x", Regular.easeIn, messageText.x, -messageText.width - 5, NAV_TWEEN_TIME, true);			var tween2:Tween = new Tween(postHasteTitle, "x", Regular.easeIn, postHasteTitle.x, -postHasteTitle.width, NAV_TWEEN_TIME, true);			var tween3:Tween = new Tween(s1Background, "x", Regular.easeIn, 0, -s1Background.width - 5, NAV_TWEEN_TIME, true);			convertMsgToRsvpArray();			moveBackBtnOn();			s1NextBtn.visible = false;			}				private function moveS1OnRight():void {			var tween1:Tween = new Tween(messageText, "x", Regular.easeIn, messageText.x, messageTextPos, NAV_TWEEN_TIME, true);			var tween2:Tween = new Tween(postHasteTitle, "x", Regular.easeIn, postHasteTitle.x, postHasteTitlePos, NAV_TWEEN_TIME, true);			var tween3:Tween = new Tween(s1Background, "x", Regular.easeIn, s1Background.x, -2, NAV_TWEEN_TIME, true);			moveBackBtnOff();			s1NextBtn.visible = true;		}				private function moveS2OnLeft():void {			var tween1:Tween = new Tween(s2Background, "x", Regular.easeIn, stage.stageWidth + 5, -2, NAV_TWEEN_TIME, true);			//var tween2:Tween = new Tween(s2Bar, "x", Regular.easeIn, stage.stageWidth + 5, 0, NAV_TWEEN_TIME, true);			var tween2:Tween = new Tween(s2ProgBar, "x", Regular.easeIn, stage.stageWidth + 5, 0, NAV_TWEEN_TIME, true);			var tween3:Tween = new Tween(s2RsvpBg, "x", Regular.easeIn, stage.stageWidth + 5, rsvpBgPos, NAV_TWEEN_TIME, true);			var tween4:Tween = new Tween(galleryItems, "x", Regular.easeIn, stage.stageWidth + 5, galleryItemsPos, NAV_TWEEN_TIME, true);			tween3.addEventListener(TweenEvent.MOTION_FINISH, startCreation);		}				private function moveS2OffLeft():void {			exitCreation();			var tween1:Tween = new Tween(s2Background, "x", Regular.easeIn, 0, 0 - s2Background.width - 5, NAV_TWEEN_TIME, true);			var tween2:Tween = new Tween(s2ProgBar, "x", Regular.easeIn, 0, -s2Background.width - 5, NAV_TWEEN_TIME, true);			var tween3:Tween = new Tween(s2RsvpBg, "x", Regular.easeIn, rsvpBgPos, -s2RsvpBg.width - 20, NAV_TWEEN_TIME, true);			var tween4:Tween = new Tween(galleryItems, "x", Regular.easeIn, galleryItemsPos, -galleryItems.width - 20, NAV_TWEEN_TIME, true);			//removeBitmap(s2Background);		}				private function moveS2OffRight():void {			exitCreation();			var tween1:Tween = new Tween(s2Background, "x", Regular.easeIn, 0, stage.stageWidth + 5, NAV_TWEEN_TIME, true);			var tween2:Tween = new Tween(s2ProgBar, "x", Regular.easeIn, 0, stage.stageWidth + 5, NAV_TWEEN_TIME, true);			var tween3:Tween = new Tween(s2RsvpBg, "x", Regular.easeIn, rsvpBgPos, stage.stageWidth + 50, NAV_TWEEN_TIME, true);			var tween4:Tween = new Tween(galleryItems, "x", Regular.easeIn, galleryItemsPos, stage.stageWidth + 50, NAV_TWEEN_TIME, true);			//removeBitmap(s2Background);		}		private function moveS3OnLeft():void {			clearProgressOverlay(s3ProgBar);			var tween1:Tween = new Tween(s3Background, "x", Regular.easeIn, stage.stageWidth + 5, -2, NAV_TWEEN_TIME, true);			var tween2:Tween = new Tween(rsvpPreviewBg, "x", Regular.easeIn, stage.stageWidth + 5, rsvpBgPos, NAV_TWEEN_TIME, true);			tween2.addEventListener(TweenEvent.MOTION_FINISH, startPreview);		}		private function moveS3OffRight():void {			exitPreviewMovie();			var tween1:Tween = new Tween(s3Background, "x", Regular.easeIn, 0, stage.stageWidth + 5, NAV_TWEEN_TIME, true);			var tween2:Tween = new Tween(rsvpPreviewBg, "x", Regular.easeIn, rsvpBgPos, stage.stageWidth + 5, NAV_TWEEN_TIME, true);			removeBitmap(s3Background);		}				private function moveBackBtnOn():void {			var tween1:Tween = new Tween(backBtn, "x", Regular.easeIn, stage.stageWidth + 5, 5 + backBtn.width/2, NAV_TWEEN_TIME, true);		}				private function moveBackBtnOff():void {			var tween1:Tween = new Tween(backBtn, "x", Regular.easeIn, backBtn.x, stage.stageWidth + 5 + backBtn.width/2, NAV_TWEEN_TIME, true);		}						/*			RSVP MESSAGE HANDLING METHODS		*/		private function setRsvpLength():void {			// Figure out how wide we can make the RSVP text			// with the current text format.  Other GUI toolkits			// have far better ways to do this, and may Flash			// does to, but it's not obvious, so try this hack.			rsvpTextField.text = "X";			RSVP_LENGTH = rsvpTextField.width / rsvpTextField.textWidth;			rsvpTextField.y = rsvpPreviewBg.y - rsvpTextField.textHeight/4;			s2RsvpTextField.y = s2RsvpBg.y - rsvpTextField.textHeight/4;			rsvpTextField.text = "";		} 		 		private function convertMsgToRsvpArray() {			//var messageTextArray:Array = messageText.text.split(' ');			var messageTextArray:Array = messageText.text.split(/\s/);			trace(messageTextArray);			rsvpPiecesArray = new Array();			for (var rsvpIndex:uint = 0; rsvpIndex < messageTextArray.length;) {				var dispString:String = "";				for (; rsvpIndex < messageTextArray.length; rsvpIndex++) {					// Check the last character; do this on a brand new loop, not after					// adding the nextPiece below, so that the rsvpIndex gets incremented					if (isPunctuationLine(dispString))						break;									var nextPiece:String = messageTextArray[rsvpIndex] as String;					if (dispString.length != 0 && (dispString.length + nextPiece.length) > RSVP_LENGTH)						break;									dispString += " " + nextPiece;				}				trace(dispString);				rsvpPiecesArray.push(dispString);			}			buildRsvpProgressBar();		}				private function buildRsvpProgressBar():void {			clearProgressOverlay(s2ProgBar);			clearProgressPieces(s2ProgBar);			clearProgressOverlay(s3ProgBar);			clearProgressPieces(s3ProgBar);						var numPieces:uint = rsvpPiecesArray.length;			var pieceWidth = stage.stageWidth / numPieces;			for (var i:uint = 0; i < numPieces; i++) {				var progressPiece:ProgressBgPiece = new ProgressBgPiece();				progressPiece.width = pieceWidth;				progressPiece.x = i * pieceWidth;				s2ProgBar.addChild(progressPiece);								var progressPiece2:ProgressBgPiece = new ProgressBgPiece();				progressPiece2.width = pieceWidth;				progressPiece2.x = i * pieceWidth;				s3ProgBar.addChild(progressPiece2);			}		}				private function clearProgressOverlay(progBar:ProgressBgPiece) {			for (var i:int = progBar.numChildren - 1; i >= 0; i--) {				if (progBar.getChildAt(i) is ProgressOverlay)					progBar.removeChild(progBar.getChildAt(i));			}		}				private function clearProgressPieces(progBar:ProgressBgPiece) {			for (var i:int = progBar.numChildren - 1; i >= 0; i--) {				if (progBar.getChildAt(i) is ProgressBgPiece)					progBar.removeChild(progBar.getChildAt(i));			}		}				// NOTE: Make this method wrap around for now...		private function getNextRsvpPiece():String {			var rtnString:String;			if ((curRsvpIndex + 1) in rsvpPiecesArray) {				rtnString = rsvpPiecesArray[curRsvpIndex + 1];				curRsvpIndex += 1;			} else {				rtnString = rsvpPiecesArray[0];				curRsvpIndex = 0;			}			return rtnString;		}				// NOTE: ...but not this one.  Trying to make it easier		// to add pics, theoretically.  Rethink this later.		private function getPreviousRsvpPiece():String {			var rtnString:String;			if ((curRsvpIndex - 1) in rsvpPiecesArray) {				rtnString = rsvpPiecesArray[curRsvpIndex - 1];				curRsvpIndex -= 1;			} else {				rtnString = rsvpPiecesArray[0];				curRsvpIndex = 0;			}			return rtnString;		}				private function isPunctuationLine(dispString:String):Boolean {			var lastChar:String = dispString.substr(dispString.length - 1, dispString.length - 1);			return (PUNCTUATION.indexOf(lastChar) >= 0);		}						/*		 *    PREVIEW SCREEN-RELATED METHODS		 */		private function startPreview(e:Event):void {			rsvpTextField.visible = true;			curRsvpIndex = -1;			redrawSpeedIndicator();			addEventListener(Event.ENTER_FRAME, previewMovie);		}				private function exitPreviewMovie():void {			removeEventListener(Event.ENTER_FRAME, previewMovie);			rsvpTextField.visible = false;			previewPaused = false;			afterSentence = false;			curRsvpIndex = -1;			lastRsvpUpdateTime = 0;		}				private function pausePreview(e:MouseEvent):void {			previewPaused = true;		}				private function unpausePreview(e:MouseEvent):void {			previewPaused = false;		}				private function s3RsvpSwipe(e:TransformGestureEvent):void {			trace("s3RsvpSwipe called:", e.offsetX);			if (e.offsetX == -1) {				slowDownBtnClicked(null);			}			else if (e.offsetX == +1) {				speedUpBtnClicked(null);			}		}				private function speedUpBtnClicked(e:MouseEvent):void {			if ((RSVP_DISP_TIME_NORMAL - SPEED_DELTA) < MIN_RSVP_TIME)				return;						RSVP_DISP_TIME_NORMAL -= SPEED_DELTA;			RSVP_DISP_TIME_AFTER_SENTENCE -= SPEED_DELTA;			redrawSpeedIndicator();		}				private function slowDownBtnClicked(e:MouseEvent):void {			if ((RSVP_DISP_TIME_NORMAL + SPEED_DELTA) > MAX_RSVP_TIME)				return;							RSVP_DISP_TIME_NORMAL += SPEED_DELTA;			RSVP_DISP_TIME_AFTER_SENTENCE += SPEED_DELTA;			redrawSpeedIndicator();		}				private function redrawSpeedIndicator():void {  			var fillType:String = GradientType.LINEAR;			var colors:Array = [0x000000, 0x009BC3];  			var alphas:Array = [1, 1];			var ratios:Array = [127, 255];  			var matr:Matrix = new Matrix();  			matr.createGradientBox(20, 20, 0, 0, 0);  			var spreadMethod:String = SpreadMethod.PAD;						var littleWidth:Number = MAX_RSVP_TIME - MIN_RSVP_TIME;			var diff = MAX_RSVP_TIME - RSVP_DISP_TIME_NORMAL;			var ratio = diff / littleWidth;			s3SpeedIndicator.graphics.clear();			s3SpeedIndicator.graphics.beginGradientFill(fillType, colors, alphas, ratios, matr, spreadMethod);			s3SpeedIndicator.graphics.drawRect(0,0, ratio * s3SpeedIndicator.width, s3SpeedIndicator.height);			s3SpeedIndicator.graphics.endFill();		}				private function previewMovie(e:Event):void {						if (previewPaused)				return;						var curTime:int = getTimer();			var dispTime:int;			if (afterSentence)				dispTime = RSVP_DISP_TIME_AFTER_SENTENCE;			else				dispTime = RSVP_DISP_TIME_NORMAL;							if (!(curRsvpIndex == -1 || (curTime - lastRsvpUpdateTime) > dispTime))				return;						if ((curRsvpIndex + 1) >= rsvpPiecesArray.length) {				curRsvpIndex = -1;				return;			}						afterSentence = false;			lastRsvpUpdateTime = curTime;			var dispString:String = getNextRsvpPiece();			afterSentence = isPunctuationLine(dispString);			rsvpTextField.text = dispString;			redrawProgBar(s3ProgBar);			if (curRsvpIndex in presentationDict) {				var bitmap:Bitmap = presentationDict[curRsvpIndex];				bitmap.x = 10;				bitmap.width = stage.stageWidth - 20;				bitmap.y = 20;				bitmap.height = rsvpPreviewBg.y - 80;				s3Background.addChild(bitmap);			}		}				/*		 *    PRESENTATION CREATION-RELATED METHODS		 */		private function startCreation(e:Event):void {			curRsvpIndex = -1;			s2RsvpTextField.visible = true;			s2RsvpTextField.text = getNextRsvpPiece();			redrawProgBar(s2ProgBar);		}				private function exitCreation():void {			curRsvpIndex = -1;			s2RsvpTextField.visible = false;		}				private function s2RsvpSwipe(e:TransformGestureEvent):void {			if (e.offsetX == -1) {				s2RsvpTextField.text = getNextRsvpPiece();				redrawProgBar(s2ProgBar);			}			else if (e.offsetX == +1) {				s2RsvpTextField.text = getPreviousRsvpPiece();				redrawProgBar(s2ProgBar);			}		}				private function redrawProgBar(progBar:ProgressBgPiece) {			clearProgressOverlay(progBar);			var numPieces:uint = rsvpPiecesArray.length;			var pieceWidth = stage.stageWidth / numPieces;						for(var i:uint = 0; i < curRsvpIndex + 1; i++) {				var progressOverlay = new ProgressOverlay();				progressOverlay.x = i * pieceWidth;				progressOverlay.width = pieceWidth;				progBar.addChild(progressOverlay);			}		}				private function s2BackgroundSwipe(e:TransformGestureEvent):void {			if (e.offsetX == -1) {				if (curSelectedGalleryIndex < (galleryItemsArray.length - 1)) {					selectGalleryItem(curSelectedGalleryIndex + 1);				}			}			else if (e.offsetX == +1) {				if (curSelectedGalleryIndex > 1) {					selectGalleryItem(curSelectedGalleryIndex - 1);				}			}		}						/*		 *    CAMERA ROLL AND IMAGE PICKING-RELATED METHODS		 */		function launchCameraRoll(e:Event):void {			// If the current RSVP entry already has an			// associated image, return.			try {				//testCameraRollTextField.text = "About to launch camera roll: " + e.target; 				if (curRsvpIndex in presentationDict)					return;								if (CameraRoll.supportsBrowseForImage) {					var _roll:CameraRoll = new CameraRoll();					_roll.addEventListener(MediaEvent.SELECT, imageSelected(e.target as S2PictureBg));					_roll.addEventListener(Event.CANCEL, imageSelectionCanceled);					_roll.browseForImage();				} else {					//testCameraRollTextField.text = "Camera Roll Not Supported";				}			} catch (err:Error) {				trace(err.message);				//testCameraRollTextField.text = err.message;			}		}				private function imageSelectionCanceled(e:MediaEvent):void {			//... What to do here?			//Use this to delete an existing image		}				private function imageSelected(target:S2PictureBg) {			// Closure for image selection, to keep the targeted			// film strip item that was clicked with the eventual			// selected image.			return function(e:MediaEvent):void {				var loader:ProLoader = new ProLoader();				try {					if (e.data.isAsync) {						loader.contentLoaderInfo.addEventListener( Event.COMPLETE, imageLoaded(target, loader) );						loader.contentLoaderInfo.addEventListener( IOErrorEvent.IO_ERROR, imageLoadFailed );						loader.loadFilePromise(e.data);						target.setMediaPromise(e.data);					} else {						var func = imageLoaded(target, loader);						func(null);					}				} catch (err:Error) {					trace(err.message);					//testCameraRollTextField.text = err.message;				}			}		}				private function imageLoaded(target:S2PictureBg, loader:ProLoader) {			return function(e:Event):void {				try {					presentationDict[curRsvpIndex] = loader.content as Bitmap;					target.setLoader(loader);					createNewS2PicBg(target);					selectGalleryItem(galleryItemsArray.indexOf(target));				} catch(err:Error) {					trace(err.message);					//testCameraRollTextField.text = err.message;				}			}		}				private function setCreationScreenMainImage(loader:ProLoader):void {			var bitmapOrig:Bitmap = loader.content as Bitmap;			var bitmap:Bitmap = new Bitmap(bitmapOrig.bitmapData);			bitmap.x = 10;			bitmap.width = stage.stageWidth - 35;			bitmap.y = 10;			bitmap.height = s2ProgBar.y - 105;			//removeBitmap(s2Background);			s2Background.addChild(bitmap);		}				private function imageLoadFailed(e:Event):void {			//testCameraRollTextField.text = "File loaded async failed...";			trace("File loaded async failed...");		}				private function createNewS2PicBg(target:S2PictureBg):void {			var picBg:S2PictureBg = new S2PictureBg(curRsvpIndex);			picBg.addEventListener(MouseEvent.CLICK, launchCameraRoll);			var previousWidth = galleryItems.width;			var newX = target.x + target.width + GALLERY_ITEMS_SPACING;			picBg.x = newX;			picBg.y = target.y;			picBg.width = target.width;			picBg.height = galleryItems.imgBg1.height;			galleryItems.addChild(picBg);			galleryItemsArray.push(picBg);			var newWidth = galleryItems.width;		}				private function selectGalleryItem(index:uint) {			var littleWidth:Number = galleryItems.width;			var localNumImageBgs = galleryItemsArray.length;			var bigWidth:Number = galleryItems.imgBg1.width * localNumImageBgs;			var item:S2PictureBg = galleryItemsArray[index];			var itemCenter = item.x + item.width/2;			var ratio:Number = itemCenter / bigWidth;			var outsideX:Number = ratio * littleWidth;			var newX:Number = stage.stageWidth/2 - outsideX;			trace("Centering to new X:", index, itemCenter, littleWidth, bigWidth, stage.stageWidth, ratio, outsideX, newX);			var tween2:Tween = new Tween(galleryItems, "x", Regular.easeIn, galleryItems.x, newX, 0.3, true);			if (item.loader != null)				setCreationScreenMainImage(item.loader);			curSelectedGalleryIndex = index;		}				private function removeBitmap(obj:Sprite):void {			for (var i:int = 0; i < obj.numChildren; i++) {				if (obj.getChildAt(i) is Bitmap)					obj.removeChild(obj.getChildAt(i));			}		}				private function removeLoader(obj:Sprite):void {			for (var i:int = 0; i < obj.numChildren; i++) {				if (obj.getChildAt(i) is ProLoader)					obj.removeChild(obj.getChildAt(i));			}		}				/*		 *    SAVE FILE METHODS		 */		/*private function saveFile(e:MouseEvent):void { 			//Confirm folder locations exist			try {				var dir:File = File.documentsDirectory.resolvePath("PostHaste");				dir.createDirectory();  				dir = File.documentsDirectory.resolvePath("PostHaste/Image");  				dir.createDirectory();  			} catch (e:Error) {				trace(e); 			}			//Build XML			var myXML:XML = <PostHaste></PostHaste>;			var i_pic:uint = 0;			for(var i_rsvp in rsvpPiecesArray) {				//trace(i_rsvp);				//gallerItem in galleryItemsArray				//trace("for " + galleryItem);				var frm:XML = <Frame></Frame>;				myXML.appendChild(frm);					if(i_rsvp in presentationDict) {					var img:XML = <Image>{galleryItemsArray[i_pic].fileLoc}</Image>;					frm.appendChild(img);										try {						var picSource:File = new File();						//New image file name is image{#}.jpg						var picDest:File = File.documentsDirectory.resolvePath("PostHaste/Image/img" + String(i_pic) + ".jpg");						//Copies image to directory						if(i_rsvp == 0) {							picSource.url = myXML.Frame.Image;							myXML.Frame.Image = "PostHaste/Image/img" + String(i_pic) + ".jpg";						} else {							picSource.url = String(myXML.Frame[i_rsvp].Image);							myXML.Frame[i_rsvp].Image = "PostHaste/Image/img" + String(i_pic) + ".jpg";						}						//trace(picSource.url);						if (picSource.exists) {							picSource.copyToAsync(picDest, true);						}					} catch (e:Error) {						trace("Copy Failed: " + e);						trace(myXML);					}					i_pic ++;				}				var txt:XML = <Text>{rsvpPiecesArray[i_rsvp]}</Text>;				frm.appendChild(txt);				//trace(myXML);			}			//Write XML to file			var myFile:File = File.documentsDirectory.resolvePath("PostHaste/presentation.xml");  			var fs:FileStream = new FileStream();  			fs.open(myFile,FileMode.WRITE);  			fs.writeUTFBytes(myXML.toXMLString());  			fs.close();  		}*/				private function saveFile(e:MouseEvent):void { 			//Confirm folder locations exist			try {				var dir:File = File.documentsDirectory.resolvePath("PostHaste");				dir.createDirectory();  				dir = File.documentsDirectory.resolvePath("PostHaste/Image");  				dir.createDirectory();  			} catch (e:Error) {				trace(e); 			}			//Build XML			var myXML:XML = <PostHaste></PostHaste>;			var i_pic:uint = 0;			for(var i_rsvp in rsvpPiecesArray) {				var frm:XML = <Frame></Frame>;				myXML.appendChild(frm);					if(i_rsvp in presentationDict) {					var img:XML = <Image></Image>;					frm.appendChild(img);										try {						var ext:String = ".png";						var picDest:File = File.documentsDirectory.resolvePath("PostHaste/Image/img" + String(i_pic) + ext);						//Copies image to directory						if(i_rsvp == 0) {							myXML.Frame.Image = "PostHaste/Image/img" + String(i_pic) + ext;						} else {							myXML.Frame[i_rsvp].Image = "PostHaste/Image/img" + String(i_pic) + ext;						}												var bitmap:Bitmap = presentationDict[i_rsvp] as Bitmap						var bitmapData:BitmapData = bitmap.bitmapData;						//var imageBytes:ByteArray = BMPEncoder.encode(bitmapData); // Uncomment to use the BMPEncoder						var imageBytes:ByteArray = PNGEncoder.encode(bitmapData);						var stream:FileStream = new FileStream();						stream.open(picDest, FileMode.WRITE);						stream.writeBytes(imageBytes);						stream.close();					} catch (e:Error) {						trace("Copy Failed: " + e);						trace(myXML);					}					i_pic ++;				}				var txt:XML = <Text>{rsvpPiecesArray[i_rsvp]}</Text>;				frm.appendChild(txt);			}						//Write XML to file			var myFile:File = File.documentsDirectory.resolvePath("PostHaste/presentation.xml");  			var fs:FileStream = new FileStream();  			fs.open(myFile,FileMode.WRITE);  			fs.writeUTFBytes(myXML.toXMLString());  			fs.close();			trace("FINISHED SAVE FILE!");		} 	}}